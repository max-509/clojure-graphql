
; uuid is clj-uuid
; nil interpretation as any value
; <label-name> is string
; <property-json> is json (witch need cast into hash-map, use jsonista/read-value)
;; example:
;; (j/read-value "{\"dog\": {\"name\":\"Teppo\"}}" j/keyword-keys-object-mapper)
;; ;; => {:dog {:name "Teppo"}}


; Node ;

() =>
{uuid/v0
 {:out-edges nil
  :labels   nil
  :property nil}}

(n) =>
{:n {:out-edges nil
     :labels   nil
     :property nil}}


; Node with labels ;

(n:<node-label-string>) =>
{:n {:out-edges nil
     :labels [<node-label-string>]
     :property nil}}

(n:<node-label-string1> :<node-label-string2>) =>
{:n {:out-edges nil
     :labels [<node-label-string1> <node-label-string2>]
     :property nil}}

(n ...:<node-label-string-s>...) =>
{:n {:out-edges nil
     :labels [...:<node-label-string-s>...]
     :property nil}}


; Node with labels and property ;

(n:<node-label-string-s> <node-property-json>) =>
{:n {:out-edges nil
     :labels [...:<node-label-string-s>...]
     :property <node-property-json>}}


; Node with where 
; let's implement only numeric and string values, and only "=", ">", "<" operations
; for string ONLY "="
; I think it enough

(n:<node-label-string>) where n.cost = <num-value> =>

{:n {:out-edges nil
     :labels [:<node-label-string>]
     :property [{:cost ("=" <value>)} {}]}}

(n:<node-label-string>) where n.cost  >  <num-value> =>

{:n {:out-edges nil
     :labels [:<node-label-string>]
     :property [{:cost (">" <num-value>)} {}]}}


(n:<node-label-string> <node-property-json>) where n.cost  >  <num-value> =>

{:n {:out-edges nil
     :labels [:<node-label-string>]
     :property [{:cost (">" <value>)} <node-property-json>]}}

(n:<node-label-string>) where n.name = <string-value> =>

{:n {:out-edges nil
     :labels [:<node-label-string>]
     :property [{:cost ("=" <string-value>)} {}]}}



; Node with edges ;

(n) - [] - () =>
{:n {:out-edges {uuid/v0 nil}
     :labels nil
     :property nil}}

(n) - [...:<edge-label-string-s>...] - () =>
{:n {:out-edges {uuid/v0 {:labels [...:<edge-label-string-s>...]
                          :property nil}}
     :labels nil
     :property nil}}

(n) - [...:<edge-label-string-s>... :<edge-property-json>] - () =>
{:n {:out-edges {uuid/v0 {:labels [...:<edge-label-string-s>...]
                          :property :<edge-property-json>}}
     :labels nil
     :property nil}}


; Node with edge and target node

(n) - [:<edge-label-name>] - (k) =>
{:n {:out-edges {:k {:labels [<edge-label-name>]
                     :property nil}}
     :labels nil
     :property nil}}

(n) - [:<edge-label-name>] - (k:<target-label-name>) =>
{:n {:out-edges {:k {:labels [<edge-label-name>]
                     :property nil}}
     :labels nil
     :property nil}

 :k {:out-edges nil
     :labels   [<target-label-name>]
     :property nil}}

; Node with edge, target node and another edge after

(n) - [:<label-name-1>] - (k) - [:<label-name-2>] - ()  =>
{:n {:out-edges {:k {:labels nil
                     :property nil}}
     :labels nil
     :property nil}
 :k {:out-edges {uuid/v0 {:labels [<label-name-2>]
                          :property nil}}
     :labels  nil
     :property nil}}